"use strict";const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),s=(r,s=null)=>{const i=t=>e(null==s?void 0:s.persist)&&s.persist(t);let n=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if(!e)throw new TypeError("Expecting valid event name.");if("function"!=typeof r)throw new TypeError("Expecting valid callback function.");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribe:(e,r)=>{t(e).delete(r)},unsubscribeAll:t=>e.delete(t)}})(),o=r;i(o);const a=()=>o,c=e=>{o!==e&&(o=e,i(o),n.publish("change",o))};return{set:c,get:a,update:e=>{t(e,"[update]"),c(e(a()))},subscribe:e=>(t(e,"[subscribe]"),e(o),n.subscribe("change",e))}},i=(e,t=0)=>(e=parseInt(e,10),Number.isNaN(e)?t:e),n=({total:e,limit:t,offset:r}={},s)=>({total:e=i(e,0),limit:t=i(t,i(s,10)),offset:r=i(r,0)}),o=({total:e,limit:t,offset:r})=>(r<0&&(r=Math.max(0,e+r)),r++,Math.max(Math.ceil(r/t),1)),a=({total:e,limit:t,offset:r},s)=>(s=i(s,o({total:e,limit:t,offset:r})),Math.max(t*(s-1),0)),c=(e={})=>{e=n(e);const{total:t,limit:r,offset:s}=e,i=Math.ceil(t/r),c=o(e),u=c===i,l=1===c,f=i>=c+1&&c+1,b=!1!==f,p=(b?c:c-1)*r;let h=Math.max(0,Math.min(c-1,i-1));const g=0!==h&&h;return{total:t,limit:r,offset:s,isLast:u,isFirst:l,nextPage:f,previousPage:g,hasNext:b,hasPrevious:!1!==g,nextOffset:p,previousOffset:!1===g?0:(g-1)*r,currentPage:c,pageCount:i,firstOffset:0,lastOffset:a(e,i)}};exports.calculatePaging=c,exports.createPagingStore=(i={},o=10)=>{const a=s(n(i,o)),u=((i,n,o=null)=>{const a=t=>e(null==o?void 0:o.persist)&&o.persist(t),c=s(null==o?void 0:o.initialValue),u=[];if(i.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>u.push(e)))()})),!e(n))throw new TypeError("Expecting second argument to be the derivative function");if(!n.length||n.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let l=0,f=[];const b=e=>{t(e,"[derived.subscribe]"),l++||i.forEach(((e,t)=>{f.push(e.subscribe((e=>{u[t]=e,1===n.length?(c.set(n(u)),a(c.get())):n(u,(e=>{c.set(e),a(c.get())}))})))}));const r=c.subscribe(e);return()=>{--l||(f.forEach((e=>e())),f=[]),r()}};return{get:()=>{let e;return b((t=>e=t))(),e},subscribe:b}})([a],(([e])=>c(e)));return{subscribe:u.subscribe,get:u.get,update:e=>a.update((t=>n({...t,...e},o))),reset:(e=null)=>a.set(n({},e||o))}};
