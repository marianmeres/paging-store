"use strict";class e{#e=new Map;publish(e,t){return this.#e.get(e)?.forEach(e=>e(t)),"*"!==e&&this.#e.get("*")?.forEach(e=>e(t)),this.#e.has(e)}subscribe(e,t){return this.#e.has(e)||this.#e.set(e,new Set),this.#e.get(e).add(t),()=>this.unsubscribe(e,t)}unsubscribe(e,t){if(!this.#e.has(e))return!1;const s=this.#e.get(e);let r=!0;return"function"==typeof t?(r=s.delete(t),0===s?.size&&this.#e.delete(e)):this.#e.delete(e),r}subscribeOnce(e,t){const s=r=>{t(r),this.unsubscribe(e,s)};return this.subscribe(e,s)}unsubscribeAll(e){return e?!!this.#e.has(e)&&(this.#e.delete(e),!0):(this.#e.clear(),!0)}__dump(){return Object.fromEntries(this.#e.entries())}}const t=e=>"function"==typeof e,s=(e,s="")=>{if(!t(e))throw new TypeError(`${s} Expecting function arg`.trim())},r=(r,i=null)=>{const o=e=>t(null==i?void 0:i.persist)&&i.persist(e);let n=new e,a=r;o(a);const l=()=>a,u=e=>{a!==e&&(a=e,o(a),n.publish("change",a))};return{set:u,get:l,update:e=>{s(e,"[update]"),u(e(l()))},subscribe:e=>(s(e,"[subscribe]"),e(a),n.subscribe("change",e))}},i=(e,i,o=null)=>{const n=e=>t(null==o?void 0:o.persist)&&o.persist(e),a=r(null==o?void 0:o.initialValue),l=[];if(e.forEach(e=>{if(!(e=>t(e.subscribe))(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe(e=>l.push(e))()}),!t(i))throw new TypeError("Expecting second argument to be the derivative function");if(!i.length||i.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let u=0,c=[];const h=t=>{s(t,"[derived.subscribe]"),u++||e.forEach((e,t)=>{c.push(e.subscribe(e=>{l[t]=e,1===i.length?(a.set(i(l)),n(a.get())):i(l,e=>{a.set(e),n(a.get())})}))});const r=a.subscribe(t);return()=>{--u||(c.forEach(e=>e()),c=[]),r()}};return{get:()=>{let e;return h(t=>e=t)(),e},subscribe:h}};let o={};const n=(e,t=0)=>(e=parseInt(e,10),Number.isNaN(e)?t:e),a=({total:e,limit:t,offset:s}={},r)=>({total:e=n(e,0),limit:t=n(t,n(r,10)),offset:s=n(s,0)}),l=({total:e,limit:t,offset:s})=>(s<0&&(s=Math.max(0,e+s)),s++,Math.max(Math.ceil(s/t),1)),u=({total:e,limit:t,offset:s},r)=>(r=n(r,l({total:e,limit:t,offset:s})),Math.max(t*(r-1),0)),c=(e={})=>{e=a(e);const{total:t,limit:s,offset:r}=e,i=Math.ceil(t/s),o=l(e),n=o===i,c=1===o,h=i>=o+1&&o+1,f=!1!==h,g=(f?o:o-1)*s;let b=Math.max(0,Math.min(o-1,i-1));const p=0!==b&&b,d=!1===p?0:(p-1)*s;return{total:t,limit:s,offset:r,isLast:n,isFirst:c,nextPage:h,previousPage:p,hasNext:f,hasPrevious:!1!==p,nextOffset:g,previousOffset:d,currentPage:o,pageCount:i,firstOffset:0,lastOffset:u(e,i),get previosOffset(){return console.warn("WARN: 'previosOffset' was renamed to 'previousOffset'"),d}}},h=(e={},t=10,s=null)=>{const o=r(a(e,t),s),n=i([o],([e])=>c(e));return{subscribe:n.subscribe,get:n.get,update:e=>o.update(s=>a({...s,...e},t)),reset:(e=null)=>o.set(a({},e||t))}};exports.calculatePaging=c,exports.createPagingStore=h,exports.createStoragePagingStore=function(e,t="session",s={},r=10){const i=((e,t="session")=>{if("memory"===t)return(e=>({remove:()=>{delete o[e]},set:t=>{o[e]=t},get:()=>o[e],clear:()=>{o={}},__raw:()=>o}))(e);const s="session"===t?null===globalThis||void 0===globalThis?void 0:globalThis.sessionStorage:null===globalThis||void 0===globalThis?void 0:globalThis.localStorage;return{remove:()=>null==s?void 0:s.removeItem(e),set:t=>{try{null==s||s.setItem(e,JSON.stringify(t))}catch(e){console.error(e)}},get:()=>{try{return JSON.parse(null==s?void 0:s.getItem(e))}catch(e){}},clear:()=>{try{s.clear()}catch(e){}},__raw:()=>s}})(e,t);return h(i.get()||s,r,{persist:i.set})},exports.pagingGetOffsetByPage=u,exports.pagingGetPageByOffset=l;
