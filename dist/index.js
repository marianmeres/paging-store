const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),s=(r,s=null)=>{const i=t=>e(null==s?void 0:s.persist)&&s.persist(t);let n=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if(!e)throw new TypeError("Expecting valid event name.");if("function"!=typeof r)throw new TypeError("Expecting valid callback function.");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribe:(e,r)=>{t(e).delete(r)},unsubscribeAll:t=>e.delete(t)}})(),o=r;i(o);const a=()=>o,u=e=>{o!==e&&(o=e,i(o),n.publish("change",o))};return{set:u,get:a,update:e=>{t(e,"[update]"),u(e(a()))},subscribe:e=>(t(e,"[subscribe]"),e(o),n.subscribe("change",e))}},i=(e,t=0)=>(e=parseInt(e,10),Number.isNaN(e)?t:e),n=({total:e,limit:t,offset:r}={},s)=>({total:e=i(e,0),limit:t=i(t,i(s,10)),offset:r=i(r,0)}),o=({total:e,limit:t,offset:r})=>(r<0&&(r=Math.max(0,e+r)),r++,Math.max(Math.ceil(r/t),1)),a=({total:e,limit:t,offset:r},s)=>(s=i(s,o({total:e,limit:t,offset:r})),Math.max(t*(s-1),0)),u=(e={})=>{e=n(e);const{total:t,limit:r,offset:s}=e,i=Math.ceil(t/r),u=o(e),c=u===i,l=1===u,f=i>=u+1&&u+1,b=!1!==f,h=(b?u:u-1)*r;let p=Math.max(0,Math.min(u-1,i-1));const g=0!==p&&p;return{total:t,limit:r,offset:s,isLast:c,isFirst:l,nextPage:f,previousPage:g,hasNext:b,hasPrevious:!1!==g,nextOffset:h,previousOffset:!1===g?0:(g-1)*r,currentPage:u,pageCount:i,firstOffset:0,lastOffset:a(e,i)}},c=(i={},o=10)=>{const a=s(n(i,o)),c=((i,n,o=null)=>{const a=t=>e(null==o?void 0:o.persist)&&o.persist(t),u=s(null==o?void 0:o.initialValue),c=[];if(i.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>c.push(e)))()})),!e(n))throw new TypeError("Expecting second argument to be the derivative function");if(!n.length||n.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let l=0,f=[];const b=e=>{t(e,"[derived.subscribe]"),l++||i.forEach(((e,t)=>{f.push(e.subscribe((e=>{c[t]=e,1===n.length?(u.set(n(c)),a(u.get())):n(c,(e=>{u.set(e),a(u.get())}))})))}));const r=u.subscribe(e);return()=>{--l||(f.forEach((e=>e())),f=[]),r()}};return{get:()=>{let e;return b((t=>e=t))(),e},subscribe:b}})([a],(([e])=>u(e)));return{subscribe:c.subscribe,get:c.get,update:e=>a.update((t=>n({...t,...e},o))),reset:(e=null)=>a.set(n({},e||o))}};export{u as calculatePaging,c as createPagingStore};
