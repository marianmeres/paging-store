class e{#e=new Map;publish(e,t){return this.#e.get(e)?.forEach(e=>e(t)),"*"!==e&&this.#e.get("*")?.forEach(e=>e(t)),this.#e.has(e)}subscribe(e,t){return this.#e.has(e)||this.#e.set(e,new Set),this.#e.get(e).add(t),()=>this.unsubscribe(e,t)}unsubscribe(e,t){if(!this.#e.has(e))return!1;const s=this.#e.get(e);let r=!0;return"function"==typeof t?(r=s.delete(t),0===s?.size&&this.#e.delete(e)):this.#e.delete(e),r}subscribeOnce(e,t){const s=r=>{t(r),this.unsubscribe(e,s)};return this.subscribe(e,s)}unsubscribeAll(e){return e?!!this.#e.has(e)&&(this.#e.delete(e),!0):(this.#e.clear(),!0)}__dump(){return Object.fromEntries(this.#e.entries())}}const t=e=>"function"==typeof e,s=(e,s="")=>{if(!t(e))throw new TypeError(`${s} Expecting function arg`.trim())},r=(r,i=null)=>{const n=e=>t(null==i?void 0:i.persist)&&i.persist(e);let o=new e,l=r;n(l);const a=()=>l,u=e=>{l!==e&&(l=e,n(l),o.publish("change",l))};return{set:u,get:a,update:e=>{s(e,"[update]"),u(e(a()))},subscribe:e=>(s(e,"[subscribe]"),e(l),o.subscribe("change",e))}},i=(e,i,n=null)=>{const o=e=>t(null==n?void 0:n.persist)&&n.persist(e),l=r(null==n?void 0:n.initialValue),a=[];if(e.forEach(e=>{if(!(e=>t(e.subscribe))(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe(e=>a.push(e))()}),!t(i))throw new TypeError("Expecting second argument to be the derivative function");if(!i.length||i.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let u=0,c=[];const h=t=>{s(t,"[derived.subscribe]"),u++||e.forEach((e,t)=>{c.push(e.subscribe(e=>{a[t]=e,1===i.length?(l.set(i(a)),o(l.get())):i(a,e=>{l.set(e),o(l.get())})}))});const r=l.subscribe(t);return()=>{--u||(c.forEach(e=>e()),c=[]),r()}};return{get:()=>{let e;return h(t=>e=t)(),e},subscribe:h}};let n={};const o=(e,t=0)=>(e=parseInt(e,10),Number.isNaN(e)?t:e),l=({total:e,limit:t,offset:s}={},r)=>({total:e=o(e,0),limit:t=o(t,o(r,10)),offset:s=o(s,0)}),a=({total:e,limit:t,offset:s})=>(s<0&&(s=Math.max(0,e+s)),s++,Math.max(Math.ceil(s/t),1)),u=({total:e,limit:t,offset:s},r)=>(r=o(r,a({total:e,limit:t,offset:s})),Math.max(t*(r-1),0)),c=(e={})=>{e=l(e);const{total:t,limit:s,offset:r}=e,i=Math.ceil(t/s),n=a(e),o=n===i,c=1===n,h=i>=n+1&&n+1,f=!1!==h,b=(f?n:n-1)*s;let g=Math.max(0,Math.min(n-1,i-1));const p=0!==g&&g,d=!1===p?0:(p-1)*s;return{total:t,limit:s,offset:r,isLast:o,isFirst:c,nextPage:h,previousPage:p,hasNext:f,hasPrevious:!1!==p,nextOffset:b,previousOffset:d,currentPage:n,pageCount:i,firstOffset:0,lastOffset:u(e,i),get previosOffset(){return console.warn("WARN: 'previosOffset' was renamed to 'previousOffset'"),d}}},h=(e={},t=10,s=null)=>{const n=r(l(e,t),s),o=i([n],([e])=>c(e));return{subscribe:o.subscribe,get:o.get,update:e=>n.update(s=>l({...s,...e},t)),reset:(e=null)=>n.set(l({},e||t))}};function f(e,t="session",s={},r=10){const i=((e,t="session")=>{if("memory"===t)return(e=>({remove:()=>{delete n[e]},set:t=>{n[e]=t},get:()=>n[e],clear:()=>{n={}},__raw:()=>n}))(e);const s="session"===t?null===globalThis||void 0===globalThis?void 0:globalThis.sessionStorage:null===globalThis||void 0===globalThis?void 0:globalThis.localStorage;return{remove:()=>null==s?void 0:s.removeItem(e),set:t=>{try{null==s||s.setItem(e,JSON.stringify(t))}catch(e){console.error(e)}},get:()=>{try{return JSON.parse(null==s?void 0:s.getItem(e))}catch(e){}},clear:()=>{try{s.clear()}catch(e){}},__raw:()=>s}})(e,t);return h(i.get()||s,r,{persist:i.set})}export{c as calculatePaging,h as createPagingStore,f as createStoragePagingStore,u as pagingGetOffsetByPage,a as pagingGetPageByOffset};
