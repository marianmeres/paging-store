const t=t=>"function"==typeof t,e=(e,s="")=>{if(!t(e))throw new TypeError(`${s} Expecting function arg`.trim())},s=e=>t(e.subscribe),r=(s=undefined,r=null)=>{const i=e=>t(r?.persist)&&r.persist(e);let n=(()=>{const t=new Map,e=e=>(t.has(e)||t.set(e,new Set),t.get(e)),s=(t,s)=>{if("function"!=typeof s)throw new TypeError("Expecting callback function as second argument");return e(t).add(s),()=>e(t).delete(s)};return{publish:(t,s={})=>{e(t).forEach((t=>t(s)))},subscribe:s,subscribeOnce:(t,e)=>{const r=s(t,(t=>{e(t),r()}));return r},unsubscribeAll:e=>t.delete(e)}})(),o=s;i(o);const a=()=>o,c=t=>{o!==t&&(o=t,i(o),n.publish("change",o))};return{set:c,get:a,update:t=>{e(t,"[update]"),c(t(a()))},subscribe:t=>(e(t,"[subscribe]"),t(o),n.subscribe("change",t))}},i=(t,e=0)=>(t=parseInt(t,10),Number.isNaN(t)?e:t),n=({total:t,limit:e,offset:s}={},r)=>({total:t=i(t,0),limit:e=i(e,i(r,10)),offset:s=i(s,0)}),o=({total:t,limit:e,offset:s})=>(s<0&&(s=Math.max(0,t+s)),s++,Math.max(Math.ceil(s/e),1)),a=({total:t,limit:e,offset:s},r)=>(r=i(r,o({total:t,limit:e,offset:s})),Math.max(e*(r-1),0)),c=(t={})=>{t=n(t);const{total:e,limit:s,offset:r}=t,i=Math.ceil(e/s),c=o(t),u=c===i,f=1===c,l=i>=c+1&&c+1,b=!1!==l,h=(b?c:c-1)*s;let p=Math.max(0,Math.min(c-1,i-1));const g=0!==p&&p;return{total:e,limit:s,offset:r,isLast:u,isFirst:f,nextPage:l,previousPage:g,hasNext:b,hasPrevious:!1!==g,nextOffset:h,previosOffset:!1===g?0:(g-1)*s,currentPage:c,pageCount:i,firstOffset:0,lastOffset:a(t,i)}},u=(i={},o=10)=>{const a=r(n(i,o)),u=((i,n,o=null)=>{const a=e=>t(o?.persist)&&o.persist(e),c=r(o?.initialValue),u=[];if(i.forEach((t=>{if(!s(t))throw new TypeError("Expecting array of StoreLike objects");t.subscribe((t=>u.push(t)))()})),!t(n))throw new TypeError("Expecting second argument to be the derivative function");if(!n.length||n.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let f=0,l=[];return{get:c.get,subscribe:t=>{e(t,"[derived.subscribe]"),f++||i.forEach(((t,e)=>{l.push(t.subscribe((t=>{u[e]=t,1===n.length?(c.set(n(u)),a(c.get())):n(u,(t=>{c.set(t),a(c.get())}))})))}));const s=c.subscribe(t);return()=>{--f||(l.forEach((t=>t())),l=[]),s()}}}})([a],(([t])=>c(t)));return{subscribe:u.subscribe,get:u.get,update:t=>a.update((e=>n({...e,...t},o))),reset:(t=null)=>a.set(n({},t||o))}};export{c as calculatePaging,u as createPagingStore};
