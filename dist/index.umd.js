!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).ticker={})}(this,function(e){"use strict";class t{#e=new Map;publish(e,t){return this.#e.get(e)?.forEach(e=>e(t)),"*"!==e&&this.#e.get("*")?.forEach(e=>e(t)),this.#e.has(e)}subscribe(e,t){return this.#e.has(e)||this.#e.set(e,new Set),this.#e.get(e).add(t),()=>this.unsubscribe(e,t)}unsubscribe(e,t){if(!this.#e.has(e))return!1;const s=this.#e.get(e);let r=!0;return"function"==typeof t?(r=s.delete(t),0===s?.size&&this.#e.delete(e)):this.#e.delete(e),r}subscribeOnce(e,t){const s=r=>{t(r),this.unsubscribe(e,s)};return this.subscribe(e,s)}unsubscribeAll(e){return e?!!this.#e.has(e)&&(this.#e.delete(e),!0):(this.#e.clear(),!0)}__dump(){return Object.fromEntries(this.#e.entries())}}const s=e=>"function"==typeof e,r=(e,t="")=>{if(!s(e))throw new TypeError(`${t} Expecting function arg`.trim())},i=(e,i=null)=>{const n=e=>s(null==i?void 0:i.persist)&&i.persist(e);let o=new t,a=e;n(a);const l=()=>a,u=e=>{a!==e&&(a=e,n(a),o.publish("change",a))};return{set:u,get:l,update:e=>{r(e,"[update]"),u(e(l()))},subscribe:e=>(r(e,"[subscribe]"),e(a),o.subscribe("change",e))}},n=(e,t,n=null)=>{const o=e=>s(null==n?void 0:n.persist)&&n.persist(e),a=i(null==n?void 0:n.initialValue),l=[];if(e.forEach(e=>{if(!(e=>s(e.subscribe))(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe(e=>l.push(e))()}),!s(t))throw new TypeError("Expecting second argument to be the derivative function");if(!t.length||t.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let u=0,c=[];const f=s=>{r(s,"[derived.subscribe]"),u++||e.forEach((e,s)=>{c.push(e.subscribe(e=>{l[s]=e,1===t.length?(a.set(t(l)),o(a.get())):t(l,e=>{a.set(e),o(a.get())})}))});const i=a.subscribe(s);return()=>{--u||(c.forEach(e=>e()),c=[]),i()}};return{get:()=>{let e;return f(t=>e=t)(),e},subscribe:f}};let o={};const a=(e,t=0)=>(e=parseInt(e,10),Number.isNaN(e)?t:e),l=({total:e,limit:t,offset:s}={},r)=>({total:e=a(e,0),limit:t=a(t,a(r,10)),offset:s=a(s,0)}),u=({total:e,limit:t,offset:s})=>(s<0&&(s=Math.max(0,e+s)),s++,Math.max(Math.ceil(s/t),1)),c=({total:e,limit:t,offset:s},r)=>(r=a(r,u({total:e,limit:t,offset:s})),Math.max(t*(r-1),0)),f=(e={})=>{e=l(e);const{total:t,limit:s,offset:r}=e,i=Math.ceil(t/s),n=u(e),o=n===i,a=1===n,f=i>=n+1&&n+1,h=!1!==f,g=(h?n:n-1)*s;let b=Math.max(0,Math.min(n-1,i-1));const p=0!==b&&b,d=!1===p?0:(p-1)*s;return{total:t,limit:s,offset:r,isLast:o,isFirst:a,nextPage:f,previousPage:p,hasNext:h,hasPrevious:!1!==p,nextOffset:g,previousOffset:d,currentPage:n,pageCount:i,firstOffset:0,lastOffset:c(e,i),get previosOffset(){return console.warn("WARN: 'previosOffset' was renamed to 'previousOffset'"),d}}},h=(e={},t=10,s=null)=>{const r=i(l(e,t),s),o=n([r],([e])=>f(e));return{subscribe:o.subscribe,get:o.get,update:e=>r.update(s=>l({...s,...e},t)),reset:(e=null)=>r.set(l({},e||t))}};e.calculatePaging=f,e.createPagingStore=h,e.createStoragePagingStore=function(e,t="session",s={},r=10){const i=((e,t="session")=>{if("memory"===t)return(e=>({remove:()=>{delete o[e]},set:t=>{o[e]=t},get:()=>o[e],clear:()=>{o={}},__raw:()=>o}))(e);const s="session"===t?null===globalThis||void 0===globalThis?void 0:globalThis.sessionStorage:null===globalThis||void 0===globalThis?void 0:globalThis.localStorage;return{remove:()=>null==s?void 0:s.removeItem(e),set:t=>{try{null==s||s.setItem(e,JSON.stringify(t))}catch(e){console.error(e)}},get:()=>{try{return JSON.parse(null==s?void 0:s.getItem(e))}catch(e){}},clear:()=>{try{s.clear()}catch(e){}},__raw:()=>s}})(e,t);return h(i.get()||s,r,{persist:i.set})},e.pagingGetOffsetByPage=c,e.pagingGetPageByOffset=u});
