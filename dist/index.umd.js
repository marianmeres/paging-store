!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).ticker={})}(this,(function(e){"use strict";const t=e=>"function"==typeof e,s=(e,s="")=>{if(!t(e))throw new TypeError(`${s} Expecting function arg`.trim())},r=e=>t(e.subscribe),i=(e,r=null)=>{const i=e=>t(null==r?void 0:r.persist)&&r.persist(e);let n=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),s=(e,s)=>{if(!e)throw new TypeError("Expecting valid event name.");if("function"!=typeof s)throw new TypeError("Expecting valid callback function.");return t(e).add(s),()=>t(e).delete(s)};return{publish:(e,s)=>{t(e).forEach((e=>e(s)))},subscribe:s,subscribeOnce:(e,t)=>{const r=s(e,(e=>{t(e),r()}));return r},unsubscribe:(e,s)=>{t(e).delete(s)},unsubscribeAll:t=>e.delete(t)}})(),o=e;i(o);const a=()=>o,u=e=>{o!==e&&(o=e,i(o),n.publish("change",o))};return{set:u,get:a,update:e=>{s(e,"[update]"),u(e(a()))},subscribe:e=>(s(e,"[subscribe]"),e(o),n.subscribe("change",e))}},n=(e,t=0)=>(e=parseInt(e,10),Number.isNaN(e)?t:e),o=({total:e,limit:t,offset:s}={},r)=>({total:e=n(e,0),limit:t=n(t,n(r,10)),offset:s=n(s,0)}),a=({total:e,limit:t,offset:s})=>(s<0&&(s=Math.max(0,e+s)),s++,Math.max(Math.ceil(s/t),1)),u=({total:e,limit:t,offset:s},r)=>(r=n(r,a({total:e,limit:t,offset:s})),Math.max(t*(r-1),0)),c=(e={})=>{e=o(e);const{total:t,limit:s,offset:r}=e,i=Math.ceil(t/s),n=a(e),c=n===i,f=1===n,l=i>=n+1&&n+1,p=!1!==l,b=(p?n:n-1)*s;let h=Math.max(0,Math.min(n-1,i-1));const g=0!==h&&h,d=!1===g?0:(g-1)*s;return{total:t,limit:s,offset:r,isLast:c,isFirst:f,nextPage:l,previousPage:g,hasNext:p,hasPrevious:!1!==g,nextOffset:b,previousOffset:d,currentPage:n,pageCount:i,firstOffset:0,lastOffset:u(e,i),get previosOffset(){return console.warn("WARN: 'previosOffset' was renamed to 'previousOffset'"),d}}};e.calculatePaging=c,e.createPagingStore=(e={},n=10)=>{const a=i(o(e,n)),u=((e,n,o=null)=>{const a=e=>t(null==o?void 0:o.persist)&&o.persist(e),u=i(null==o?void 0:o.initialValue),c=[];if(e.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>c.push(e)))()})),!t(n))throw new TypeError("Expecting second argument to be the derivative function");if(!n.length||n.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let f=0,l=[];const p=t=>{s(t,"[derived.subscribe]"),f++||e.forEach(((e,t)=>{l.push(e.subscribe((e=>{c[t]=e,1===n.length?(u.set(n(c)),a(u.get())):n(c,(e=>{u.set(e),a(u.get())}))})))}));const r=u.subscribe(t);return()=>{--f||(l.forEach((e=>e())),l=[]),r()}};return{get:()=>{let e;return p((t=>e=t))(),e},subscribe:p}})([a],(([e])=>c(e)));return{subscribe:u.subscribe,get:u.get,update:e=>a.update((t=>o({...t,...e},n))),reset:(e=null)=>a.set(o({},e||n))}}}));
