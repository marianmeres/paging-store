!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).ticker={})}(this,(function(e){"use strict";const t=e=>"function"==typeof e,s=(e,s="")=>{if(!t(e))throw new TypeError(`${s} Expecting function arg`.trim())},i=e=>t(e.subscribe),r=(e,i=null)=>{const r=e=>t(null==i?void 0:i.persist)&&i.persist(e);let n=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),s=(e,s)=>{if(!e)throw new TypeError("Expecting valid event name.");if("function"!=typeof s)throw new TypeError("Expecting valid callback function.");return t(e).add(s),()=>t(e).delete(s)};return{publish:(e,s)=>{t(e).forEach((e=>e(s)))},subscribe:s,subscribeOnce:(e,t)=>{const i=s(e,(e=>{t(e),i()}));return i},unsubscribe:(e,s)=>{t(e).delete(s)},unsubscribeAll:t=>e.delete(t)}})(),o=e;r(o);const a=()=>o,u=e=>{o!==e&&(o=e,r(o),n.publish("change",o))};return{set:u,get:a,update:e=>{s(e,"[update]"),u(e(a()))},subscribe:e=>(s(e,"[subscribe]"),e(o),n.subscribe("change",e))}},n=(e,t=0)=>(e=parseInt(e,10),Number.isNaN(e)?t:e),o=({total:e,limit:t,offset:s}={},i)=>({total:e=n(e,0),limit:t=n(t,n(i,10)),offset:s=n(s,0)}),a=({total:e,limit:t,offset:s})=>(s<0&&(s=Math.max(0,e+s)),s++,Math.max(Math.ceil(s/t),1)),u=({total:e,limit:t,offset:s},i)=>(i=n(i,a({total:e,limit:t,offset:s})),Math.max(t*(i-1),0)),c=(e={})=>{e=o(e);const{total:t,limit:s,offset:i}=e,r=Math.ceil(t/s),n=a(e),c=n===r,l=1===n,f=r>=n+1&&n+1,b=!1!==f,p=(b?n:n-1)*s;let h=Math.max(0,Math.min(n-1,r-1));const g=0!==h&&h;return{total:t,limit:s,offset:i,isLast:c,isFirst:l,nextPage:f,previousPage:g,hasNext:b,hasPrevious:!1!==g,nextOffset:p,previousOffset:!1===g?0:(g-1)*s,currentPage:n,pageCount:r,firstOffset:0,lastOffset:u(e,r)}};e.calculatePaging=c,e.createPagingStore=(e={},n=10)=>{const a=r(o(e,n)),u=((e,n,o=null)=>{const a=e=>t(null==o?void 0:o.persist)&&o.persist(e),u=r(null==o?void 0:o.initialValue),c=[];if(e.forEach((e=>{if(!i(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>c.push(e)))()})),!t(n))throw new TypeError("Expecting second argument to be the derivative function");if(!n.length||n.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let l=0,f=[];const b=t=>{s(t,"[derived.subscribe]"),l++||e.forEach(((e,t)=>{f.push(e.subscribe((e=>{c[t]=e,1===n.length?(u.set(n(c)),a(u.get())):n(c,(e=>{u.set(e),a(u.get())}))})))}));const i=u.subscribe(t);return()=>{--l||(f.forEach((e=>e())),f=[]),i()}};return{get:()=>{let e;return b((t=>e=t))(),e},subscribe:b}})([a],(([e])=>c(e)));return{subscribe:u.subscribe,get:u.get,update:e=>a.update((t=>o({...t,...e},n))),reset:(e=null)=>a.set(o({},e||n))}}}));
